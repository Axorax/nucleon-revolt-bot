const { Client } = require("revolt.js");
const fs = require("fs");
const config = require("./config.json");
const express = require("express");
const mongoose = require("mongoose");
const mongo = require("./mongodb.js");
const Uploader = require("./uploader.js");
const { spawn } = require("child_process");
const utils = require("./utils.js");
const os = require("os");

// ==== CREDENTIALS

CREDS_MONGODB = "";
CREDS_TOKEN = "";
CREDS_WEBHOOK = "";

// ==== END

if (!config.LOG_ERRORS_IN_CONSOLE) {
  console.warn = console.error = () => {};
}

console.debug = (..._) => {
  return "x";
};

let info = {
  messages: [],
  commandsRan: 0,
};

let serverPort;

let serverPin = utils.randomString(config.SERVER_PIN_LENGTH);

const client = new Client();
const uploader = new Uploader(client);
const app = express();

(async () => {
  if (CREDS_MONGODB == "skip") {
    return console.log("\x1b[33m[√] Skipped MongoDB connection\x1b[0m");
  } else {
    await mongoose.connect(CREDS_MONGODB);
    console.log("\x1b[92m[√] Connected to MongoDB\x1b[0m");
  }
})();

const PREFIX = config.PREFIX;
global.commands = new Map();

// Create help command

fs.writeFileSync("db/help-msg-autogenerated.json", "", function (e) {
  console.log(e);
});

const helpData = config.HELP;
let helpMsg = {
  root: `**Bot Prefix:** \`?\` or \`<@mention> <command>\`\n${config.HELP_NOTICE}\n`,
};

Object.keys(helpData).forEach((category) => {
  helpMsg.root += `\`${PREFIX}help ${category}\`\n`;
  Object.keys(helpData[category]).forEach((command) => {
    const x = helpMsg[category] || "";
    helpMsg[category] =
      x + `\`?${command}\` — ${helpData[category][command]}\n`;
  });
});

Object.keys(helpMsg).forEach((key) => {
  helpMsg[
    key
  ] += `\n[Help improve Nucleon by donating!](https://www.patreon.com/axorax)`;
});

if (config.FORMAT_AUTOGENERATED_HELP_MESSAGE) {
  fs.writeFileSync(
    "db/help-msg-autogenerated.json",
    JSON.stringify(helpMsg, null, 4)
  );
} else {
  fs.writeFileSync("db/help-msg-autogenerated.json", JSON.stringify(helpMsg));
}

// Command handler

fs.readdirSync("./commands", {
  withFileTypes: true,
}).forEach((dir) => {
  if (dir.isFile()) return;

  const commandFiles = fs
    .readdirSync(`${"./commands"}/${dir.name}/`)
    .filter((file) => file.endsWith(".js"));

  fs.readdirSync(`${"./commands"}/${dir.name}/`, {
    withFileTypes: true,
  })
    .filter((dir) => dir.isDirectory())
    .forEach((subdir) => {
      const commandFiles = fs
        .readdirSync(`${"./commands"}/${dir.name}/${subdir.name}/`)
        .filter((file) => file.endsWith(".js"));
      for (const file of commandFiles) {
        const command = require(`./commands/${dir.name}/${subdir.name}/${file}`);
        const cmdName = file.split(".")[0];
        global.commands.set(cmdName, command);
        if (command.alias) {
          if (Array.isArray(command.alias)) {
            command.alias.forEach((e) => {
              global.commands.set(e, command);
            });
          } else {
            global.commands.set(command.alias, command);
          }
        }
        console.log("\x1b[94m[+] Loaded " + cmdName + "\x1b[0m");
      }
    });

  for (const file of commandFiles) {
    const command = require(`./commands/${dir.name}/${file}`);
    const cmdName = file.split(".")[0];
    global.commands.set(cmdName, command);
    if (command.alias) {
      if (Array.isArray(command.alias)) {
        command.alias.forEach((e) => {
          global.commands.set(e, command);
        });
      } else {
        global.commands.set(command.alias, command);
      }
    }
    console.log("\x1b[94m[+] Loaded " + cmdName + "\x1b[0m");
  }
});

// Cache users

async function cacheUsers(x) {
  console.log(
    `\x1b[33m[↪] Starting to fetch users in ${x.servers.size()} server(s).\x1b[0m`
  );
  const cachedUsers = [];
  x.servers.forEach(async (server) => {
    cachedUsers.push(server.fetchMembers());
  });
  const cacheUserPromise = await Promise.allSettled(cachedUsers);
  console.log(
    `\x1b[92m[√] Downloaded all users from ${
      cacheUserPromise.filter((r) => r.status == "fulfilled").length
    } server(s) ` +
      `with ${
        cacheUserPromise.filter((r) => r.status == "rejected").length
      } errors. Cache size: ${x.users.size()}\x1b[0m`
  );
}

// Client ready

let statusCount = 0;

const terminalWidth = process.stdout.columns || 80;

function terminalCenter(text, totalWidth) {
  const padding = Math.floor((totalWidth - text.length) / 2);
  const leftPadding = " ".repeat(padding);
  const rightPadding = " ".repeat(totalWidth - text.length - padding);
  return leftPadding + text + rightPadding;
}

client.on("ready", async () => {
  const terminalDashLength = "-".repeat(terminalWidth);
  console.info(`\x1b[92m${terminalDashLength}
${terminalCenter("Nucleon 1.0.0", terminalWidth)}
${terminalDashLength}
[ɩ] Node Version: ${process.version}
[ɩ] Logged in as ${client.user.username}
[ɩ] GUI at http://localhost:${serverPort}${
    config.SHOW_PIN_IN_CONSOLE ? `\n[ɩ] Pin: ${serverPin}` : ""
  }
${terminalDashLength}\x1b[0m`);

  cacheUsers(client);

  if (config.STATUS_LIST != false && config.STATUS_INTERVAL != false) {
    if (config.STATUS_LIST.length == 1) {
      client.user.edit({
        status: config.STATUS_LIST[0],
      });
    } else {
      setInterval(() => {
        if (statusCount > config.STATUS_LIST.length) {
          statusCount = 0;
        }
        client.user.edit({
          status: config.STATUS_LIST[statusCount],
        });
        statusCount++;
      }, config.STATUS_INTERVAL);
    }
  }
});

// Message create

client.on("messageCreate", async (message) => {
  if (message.authorId == client.user.id || message.author.bot != undefined)
    return;
  try {
    if (message.channel.server && config.STORE_USER_MESSAGES) {
      info.messages.push(
        String(
          message.authorId +
            " in " +
            message.channel.server.id +
            ": " +
            message.content
        )
      );
    }
    if (String(message.content).startsWith(PREFIX)) {
      const args = String(message.content).split(" ");
      const cmdName = args.shift().replace(PREFIX, "");
      const userMsg = String(message.content)
        .replace(PREFIX + cmdName, "")
        .replace(" ", "");
      const cmd = global.commands.get(cmdName);
      if (!cmd) return;
      info.commandsRan++;

      cmd.run(client, message, args, userMsg, {
        upload: uploader,
      });
    } else if (String(message.content).startsWith(`<@${client.user.id}>`)) {
      const args = String(message.content).split(" ");
      const cmdName = args[1];
      const userMsg = String(message.content)
        .replace(`<@${client.user._id}> ${cmdName}`, "")
        .replace(" ", "");
      const cmd = global.commands.get(cmdName);
      if (!cmd) {
        if (cmdName == undefined) {
          message.channel.sendMessage({
            embeds: [
              {
                title: "Type ?help for a list of all commands!",
                description: `My prefix is **\`${PREFIX}help\`** or **\`<@${client.user.id}> help\`**`,
              },
            ],
          });
        } else {
          message.channel.sendMessage(`**Invalid command!**`);
        }
        return;
      }
      info.commandsRan++;

      cmd.run(client, message, args, userMsg, {
        upload: uploader,
      });
    }
  } catch (error) {
    console.log(error);
  }
});

// Post data

function nucleonCrash(error) {
  sendData(`\`\`\`${error}\`\`\``, "Nucleon Crash Report");
  return;
}

if (config.EXIT_ON_ERROR) {
  return;
} else {
  if (!config.REPORT_EXCEPTION) {
    process.on("uncaughtException", () => {
      return;
    });
  } else {
    process.on("uncaughtException", nucleonCrash);
  }

  process.on("unhandledRejection", nucleonCrash);
}

function localLog(data) {
  fs.appendFile(config.LOCAL_DATA_FILENAME, `${data}\n\n----\n\n`, (err) => {
    if (err) {
      console.error("Error writing to logs.txt:", err);
    }
  });
}

function sendData(msg, name = "Nucleon Log") {
  if (CREDS_WEBHOOK == "skip") {
    return;
  } else if (CREDS_WEBHOOK == "local") {
    localLog(`${name}\n${msg}`);
  } else {
    const params = {
      username: `${name} - ${new Date().toLocaleString("en-US", {
        hour12: true,
      })}`,
      content: msg,
    };
    fetch(CREDS_WEBHOOK, {
      method: "POST",
      headers: {
        "Content-type": "application/json",
      },
      body: JSON.stringify(params),
    }).catch((error) => {
      console.log(error);
    });
  }
}

setInterval(() => {
  if (config.STORE_USER_MESSAGES) {
    sendData(`\`\`\`json
    ${JSON.stringify(info.messages, null, 2)}
    \`\`\`
    Commands ran: ${info.commandsRan}`);
    info.messages = [];
    info.commandsRan = 0;
  }
  cacheUsers(client);
}, config.CACHE_AND_STORE_INTERVAL);

client.loginBot(CREDS_TOKEN);

if (config.CHANGE_PIN_INTERVAL != false) {
  setInterval(() => {
    serverPin = utils.randomString(config.SERVER_PIN_LENGTH);
    console.log(`\x1b[92m${"-".repeat(terminalWidth)}
[ɩ] GUI at http://localhost:${serverPort}${
      config.SHOW_PIN_IN_CONSOLE ? `\n[ɩ] New Pin: ${serverPin}` : ""
    }
${"-".repeat(terminalWidth)}\x1b[0m`);
  }, config.CHANGE_PIN_INTERVAL);
}

app.use(express.static(__dirname + "/public"));
app.use(express.json());

app.set("view engine", "ejs");

app.get("/", (req, res) => {
  res.render("login");
});

app.get("/alive", (req, res) => {
  res.send("Alive!");
});

app.get("/home", (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    res.render("home", {
      serverPin,
      data: {
        username: client.user.username,
        "total server(s)": client.servers.size(),
        "total user(s)": client.users.size(),
        "total channel(s)": client.channels.size(),
        "created at": new Date(client.user.createdAt).toLocaleString(),
        online: client.user.online || false,
        "total server members": client.serverMembers.size(),
        "total emojis": client.emojis.size(),
        "event ping": client.events.ping(),
      },
    });
  } else {
    return res.redirect("/");
  }
});

app.get("/uptime", (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    res.render("uptime", { serverPin });
  } else {
    return res.redirect("/");
  }
});

app.get("/server-info", (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    const mem = process.memoryUsage();
    res.render("server-info", {
      serverPin,
      info: {
        Hostname: os.hostname(),
        "OS Type": os.type(),
        Platform: os.platform(),
        Arch: os.arch(),
        Release: os.release(),
        Uptime: os.uptime(),
        "Process Uptime": process.uptime(),
        "Load Average": os.loadavg(),
        "Total Memory": os.totalmem(),
        "Free Memory": os.freemem(),
        PID: process.pid,
        "Node Version": process.version,
        "Memory Usage RSS": mem.rss,
        "Memory Heap Total": mem.heapTotal,
        "Memory Heap Used": mem.heapUsed,
        "Memory Usage External": mem.external,
        "Memory Usage Array Buffers": mem.arrayBuffers,
        "Current Working Directory": process.cwd(),
        "Command Line Arguments": process.argv,
        Versions: process.versions,
        CPUs: os.cpus(),
        "Network Interfaces": os.networkInterfaces(),
      },
    });
  } else {
    return res.redirect("/");
  }
});

app.get("/database-actions", (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    res.render("database-actions", { serverPin });
  } else {
    return res.redirect("/");
  }
});

app.get("/status", (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    res.render("status", { serverPin });
  } else {
    return res.redirect("/");
  }
});

app.get("/dm-announcement", (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    res.render("dm-announcement", { serverPin });
  } else {
    return res.redirect("/");
  }
});

app.get("/actions", (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    res.render("actions", { serverPin, lockdown: global.lockdown });
  } else {
    return res.redirect("/");
  }
});

app.get("/mass-announcement", (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    res.render("mass-announcement", { serverPin });
  } else {
    return res.redirect("/");
  }
});

app.get("/servers", (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    let servers = [];
    let iterator = client.servers.entries();
    for (let v = iterator.next(); !v.done; v = iterator.next()) {
      servers.push(v.value[1]);
    }
    const ids = servers.map((s) => s.id);
    const names = servers.map((s) => s.name);
    const owners = servers.map((s) => s.ownerId);
    const createdAt = servers.map((s) => s.createdAt);
    const descriptions = servers.map((s) => s.description);
    const discoverable = servers.map((s) => s.discoverable);
    res.render("servers", {
      serverPin,
      discoverable,
      ids,
      names,
      owners,
      createdAt,
      descriptions,
    });
  } else {
    return res.redirect("/");
  }
});

app.get("/dm-user", (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    res.render("dm-user", { serverPin });
  } else {
    return res.redirect("/");
  }
});

app.get("/evaluate", (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    res.render("evaluate", { serverPin });
  } else {
    return res.redirect("/");
  }
});

app.get("/database", async (req, res) => {
  if (req.query.pin && req.query.pin === serverPin) {
    const users = await mongo.all();
    res.render("database", { serverPin, users });
  } else {
    return res.redirect("/");
  }
});

const middleware = (req, res, next) => {
  req.client = client;
  req.pin = serverPin;
  req.db = mongo;
  next();
};

app.use("/api", middleware, require("./routes/api.js"));
app.use("/actions", middleware, require("./routes/actions.js"));

const server = app.listen(0, () => {
  console.log("\x1b[92m[√] Nucleon server ready!\x1b[0m");
  serverPort = server.address().port;

  if (config.OPEN_GUI_ON_START) {
    const browserCommand =
      "win32" === process.platform
        ? "start"
        : "darwin" === process.platform
        ? "open"
        : "xdg-open";

    const browser = spawn(browserCommand, [`http://localhost:${serverPort}`], {
      shell: true,
    });

    browser.on("error", (err) => {
      console.log(
        `\x1b[91mFailed to open browser! Please open manually! [${serverPort}]\x1b[0m`
      );
    });
  }
});
